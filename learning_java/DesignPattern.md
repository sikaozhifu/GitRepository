#### 普通工厂模式：

​	可以扩展产品，可以生成新的产品工厂，在产品的维度；

​	缺点：如果生成新的产品系列，会造成工厂泛滥。

#### 抽象工厂模式：

​	不容易增加新的产品品种，但是可以换新的工厂系列。

​	举例：更换软件主题。

#### 桥接模式：

​	在子类的扩展有两个维度，需要解决他们之间的排列组合。

​	举例：跨平台图像浏览系统。一个维度为图像，一个维度为系统

#### 命令模式：

​	将请求发送者和接收者完全解耦，发送者维持对抽象命令的引用，接收者维持对具体实现命令的引用。

​	举例：自定义功能键。

​	缺点：会造成有过多的具体命令类。

#### 策咯模式：

​	提供算法复用机制，用户不需要知道每一种算法的具体实现。

​	举例：电影售票，针对不同群体的不同策略。Ticket类只需要拥有抽象策略的引用，具体实现由子类完成。

​	缺点：用户需要知道有哪些算法或者策略。

##### 命令与策略的区别：

​	两者面向的问题层面是不一样：

​	命令模式强调解耦发送者和接收者以实现不同的命令执行方式；

​	策略模式强调抽象出策略，以实现同种结果的不同实现。

##### 代理与装饰的异同：

​	相同：

​	装饰者模式：装饰者与被装饰者实现同一接口；

​	代理模式：代理类与被代理类实现同一接口；

​	所以两种模式都很容易在真实对象的方法前后加上自定义的方法；

​	区别：

​	装饰器模式关注在一个对象上动态的添加方法，而代理模式关注于		控制对对象的访问，即代理类可以对他的客户隐藏一个对象的具体信息，**他们的目的不同，一个是装饰，一个是限制**。

​	用法：

​	在使用代理模式的时候，我们常常在代理类中创建一个对象的实例；而在装饰者模式的时候，我们通常将原始对象作为一个参数传递给装饰者的构造器（静态代理实现），客户自己指定装饰的是哪一个类。

​	总结：

​	使用代理模式，代理对象和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。

​	举例：

​	A类是原始功能的类， B是装饰模式中对A类的扩展之后的类， C是代理模式中对A类的扩展之后的类

​       对于用户调用来说：
       使用装饰模式，用户更关系的是B的功能(包含A的原始功能)；
       使用代理模式，用户更关心A的功能，并不关心C的功能。